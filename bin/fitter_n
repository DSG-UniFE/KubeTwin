#!/usr/bin/env ruby

begin
  require 'kube_twin'
  require 'mhl'
  require 'logger'
  require 'pycall'
  require 'pycall/import'
  include PyCall::Import
  require 'csv'
rescue LoadError
  require 'rubygems'
  require 'kube_twin'
  require 'mhl'
end

def do_abort(message)
    abort <<-EOS.gsub(/^\s+\|/, '')
      |#{message}
      |
      |Usage:
      |    #{File.basename(__FILE__)} simulator_config_file testbed_file n
      |
    EOS
  end

if ARGV.length < 3
  do_abort("Uncompleted parameters")
end
  
  
if File.expand_path(__FILE__) == File.expand_path($0)
    # make sure both required arguments were given
    case ARGV.size
    when 0 then
      do_abort("Missing simulator configuration files!")
    end
  
    # make sure simulator config file exists
    unless File.exists? ARGV[0]
      do_abort("Invalid simulator configuration file!")
    end
end

unless File.exists? ARGV[1]
  do_abort("Invalid dataset log")
end

$n = ARGV[2].to_i

raise "GMM components should be greater than 3" if $n < 3

$params = $n * 3 - 1 # weight mu sigma for each component
# - 1 --> array indexes start from 0

puts "n #{$n} params #{$params}"

# pycall import
pyfrom :scipy, import: :stats

# here run the optimizer on the oracle
# load simulation configuration
time = Time.now.strftime('%Y%m%d%H%M%S')

GA_LOG = "fitter_log_#{time}_#{$n}.log"

File.delete(GA_LOG) if File.exist?(GA_LOG)
ga_logger = Logger.new(GA_LOG)
ga_logger.level = Logger::INFO

sim_conf = KUBETWIN::Configuration.load_from_file(ARGV[0])
msc = sim_conf.microservice_types

# open the log only once
k8s_log = CSV.parse(File.read(ARGV[1]), headers: true)
k8s_ttr = k8s_log.by_col[1] # get the ttr column

$microservice_types = sim_conf.microservice_types
$n_ms = $microservice_types.length

puts "Number of microservices #{$n_ms}"

$seed = 12345

def encode_replicas_set(x, n_ms)

  # for each micro-servce
  config = {}

  #puts "x:#{x}"

  x.each_slice($params).to_a.each_with_index do |ms, msi|

    #puts "Microservice: #{msi}"
    #puts "Microservice: #{ms}"
    
    #msi_istart = msi
    #msi_iend = msi * $params - $n # n is the number of component for the GMM

    # [0.15, 15, 30, 0.35, 20, 22, 30, 15] # n = 3 components
    # weights = 0.15, 0.35 

    # get last weight parameter

    w_last = 1
    (0..($params - 3)).select {|pi| pi % 3 == 0}.each do |p| 
      #puts "#{ms[p]}"
      w_last -= ms[p]
    end

    # puts "w_last #{w_last}"

    return nil if w_last < 0 # reject negative probabilities  


    #puts "ms gmm parameters: #{ms}"

    y = ms.clone
    y.insert($params - 3, w_last)

    #puts "y gmm parameters: #{y}"

    #puts $microservice_types
    microservice_name = $microservice_types.keys[msi]
    #puts "msn #{microservice_name}"
    config[microservice_name] = { distribution: :mixture, args: 
      ERV::GaussianMixtureHelper.RawParametersToMixtureArgsSeed(*y, $seed)
    }
    
    #puts config
  end

  config
end

to_optimize = lambda do |component_allocation|

    res = 0

    # load simulation configuration
    conf = KUBETWIN::Configuration.load_from_file(ARGV[0])
    msc = sim_conf.microservice_types
    processing_time = encode_replicas_set(component_allocation, msc.keys.length)
    
    if processing_time.nil?
      res = 1E+195
    else

      processing_time.each do |ms_name, ms_time_dist|
        # puts msc
        msc[ms_name][:service_time_distribution][:mec] = ms_time_dist
        # create a simulator and launch it
      end

      sim = KUBETWIN::KSimulation.new(configuration: conf,
                                  evaluator: KUBETWIN::Evaluator.new(conf))
      benchmark = sim.evaluate_allocation(nil, nil, msc)

      # evaluate bench here

      sim_log = CSV.parse(File.read(benchmark), headers: true)
      sim_ttr = sim_log.by_col[1]
      if sim_ttr.length < (k8s_ttr.length / 2)
        res = 1E+195
      else
        ks = stats.kstest(sim_ttr, k8s_ttr)
        res = ks.statistic.to_f 
        puts "#{ks}, #{res}"
      end
      File.delete(benchmark)
    end

    puts "#{res}"
    -res
end

solver_conf = {
  swarm_size: 40,
  logger: ga_logger,
  constraints: {
    min: ([0.0, 1E-5, 1E-5] * ($n-1) + [1E-5, 1E-5]) * $n_ms,
    max: ([ 1.to_f ] * $params) * $n_ms,
  },
  exit_condition: lambda {|gen, best | gen >= 1000 },
  log_level: :info,
}

solver = MHL::QuantumPSOSolver.new(solver_conf)
best = solver.solve(to_optimize, {concurrent: false})

puts best

=begin
# TODO remove code repetition
bench = lambda do |component_allocation|

  res = 0
  # load simulation configuration
  conf = KUBETWIN::Configuration.load_from_file(ARGV[0])
  msc = sim_conf.microservice_types
  processing_time = encode_replicas_set(component_allocation, msc.keys.length)

  microservice_types['MS1'][:service_time_distribution][:mec] = processing_time
 
  # create a simulator and launch it
  sim = KUBETWIN::KSimulation.new(configuration: conf,
                              evaluator: KUBETWIN::Evaluator.new(conf))
 
  benchmark = sim.evaluate_allocation(nil, nil, microservice_types)
  sim_log = CSV.parse(File.read(benchmark), headers: true)
  sim_ttr = sim_log.by_col[1]
 
  if sim_ttr.length < (k8s_ttr.length / 2)
    res = 1E+195
  else
    ks = stats.kstest(sim_ttr, k8s_ttr)
    res = ks.statistic.to_f 
    puts "#{ks}, #{res}"
  end
  puts "#{res}"
  -res
end

puts "Saving simulation benchmark for best configuration"

bench.call(best[:position])
=end

puts "exiting"
exit 0

