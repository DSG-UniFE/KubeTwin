#!/usr/bin/env ruby

begin
  require 'kube_twin'
  require 'mhl'
  require 'logger'
  require 'pycall'
  require 'pycall/import'
  include PyCall::Import
  require 'csv'
rescue LoadError
  require 'rubygems'
  require 'kube_twin'
  require 'mhl'
end

def do_abort(message)
    abort <<-EOS.gsub(/^\s+\|/, '')
      |#{message}
      |
      |Usage:
      |    #{File.basename(__FILE__)} simulator_config_file testbed_file n
      |
    EOS
  end

if ARGV.length < 3
  do_abort("Uncompleted parameters")
end
  
  
if File.expand_path(__FILE__) == File.expand_path($0)
    # make sure both required arguments were given
    case ARGV.size
    when 0 then
      do_abort("Missing simulator configuration files!")
    end
  
    # make sure simulator config file exists
    unless File.exists? ARGV[0]
      do_abort("Invalid simulator configuration file!")
    end
end

unless File.exists? ARGV[1]
  do_abort("Invalid dataset log")
end

$n = ARGV[2].to_i

raise "GMM components should be greater than 3" if $n < 3

$params = $n * 3 - 1 # weight mu sigma for each component
# - 1 --> array indexes start from 0

puts "n #{$n} params #{$params}"

# pycall import
pyfrom :scipy, import: :stats

# here run the optimizer on the oracle
# load simulation configuration
time = Time.now.strftime('%Y%m%d%H%M%S')

GA_LOG = "fitter_log_#{time}_#{$n}.log"

File.delete(GA_LOG) if File.exist?(GA_LOG)
ga_logger = Logger.new(GA_LOG)
ga_logger.level = Logger::INFO

sim_conf = KUBETWIN::Configuration.load_from_file(ARGV[0])
msc = sim_conf.microservice_types

# open the log only once
k8s_log = CSV.parse(File.read(ARGV[1]), headers: true)
k8s_ttr = k8s_log.by_col[1].map(&:to_f) # get the ttr column

# ms1 ttr
k8s_ms1 = CSV.parse(File.read(ARGV[3]), headers: true)
ms1_ttr = k8s_ms1.by_col[0].map(&:to_f) # get the ttr column
puts "MS1: max: #{ms1_ttr.max} min: #{ms1_ttr.min}"

# ms2 ttr
k8s_ms2 = CSV.parse(File.read(ARGV[4]), headers: true)
ms2_ttr = k8s_ms2.by_col[0].map(&:to_f) # get the ttr column
# ms2_ttr = ms2_ttr.select{|e| ! e.nil?}.collect {|e| e * 1E3}
puts "MS2: max: #{ms2_ttr.max} min: #{ms2_ttr.min}"

puts "TTR: max: #{k8s_ttr.max} min: #{k8s_ttr.min}"


$microservice_types = sim_conf.microservice_types
$n_ms = $microservice_types.length

puts "Number of microservices #{$n_ms}"

$seed = 12345

def encode_service_time_conf(x, n_ms)

  # for each micro-servce
  config = {}

  #puts "x:#{x}"

  x.each_slice($params).to_a.each_with_index do |ms, msi|

    #puts "Microservice: #{msi}"
    #puts "Microservice: #{ms}"
    #msi_istart = msi
    #msi_iend = msi * $params - $n # n is the number of component for the GMM

    w_last = 1
    (0..($params - 3)).select {|pi| pi % 3 == 0}.each do |p| 
      w_last -= ms[p]
    end

    # w_last = 0 if w_last < 0 # reject negative probabilities  
    # or normalize the sum of tha absolute values to 1?
    return nil if w_last < 0

    #puts "ms gmm parameters: #{ms}"
    # clone the component allocation
    y = ms.clone
    y.insert($params - 2, w_last)
    # add w_last in its position
    #puts "y gmm parameters: #{y}"

    #puts $microservice_types
    microservice_name = $microservice_types.keys[msi]
    #puts "msn #{microservice_name}"
    config[microservice_name] = { distribution: :mixture, args: 
      ERV::GaussianMixtureHelper.RawParametersToMixtureArgsSeed(*y, $seed)
    }
    
     #puts config
  end
  config
end


res = 0


component_allocation = 
[0.004226792692725739, 0.021269823094957983, 0.010939133045965584, 0.19945064289985634, 0.00649792928262739, 0.001013741877896245, 0.0048742653328895475, 1.0e-05, 0.0019969156916502077, 0.020488197406720993, 0.0001052303033019805, 0.0012854098371261448, 0.0018531931139184657, 0.015050721669347615, 0.006033563986403702, 0.0007234588978425779, 0.007849032735758269, 0.04041633964099989, 0.01559341745616441, 0.7464452311031102, 0.025746231599144482, 0.0011205157275963628, 0.02796713644326968, 0.00301431021609591]

# load simulation configuration
conf = KUBETWIN::Configuration.load_from_file(ARGV[0])
msc = sim_conf.microservice_types

processing_time = encode_service_time_conf(component_allocation, msc.keys.length)

if processing_time.nil?
  res = 1E+195
else
  processing_time.each do |ms_name, ms_time_dist|
    # puts msc
    msc[ms_name][:service_time_distribution][:mec] = ms_time_dist
    # create a simulator and launch it
  end
end

#puts msc

sim = KUBETWIN::KSimulation.new(configuration: conf,
                            evaluator: KUBETWIN::Evaluator.new(conf))
                            
benchmark, bms1, bms2 = sim.evaluate_allocation(nil, nil, msc)

# evaluate bench here

sim_log = CSV.parse(File.read(benchmark), headers: true)
sim_ttr = sim_log.by_col[1].map(&:to_f)

ms1_log = CSV.parse(File.read(bms1), headers: true)
sim_ms1_ttr = ms1_log.by_col[1].map(&:to_f)

ms2_log = CSV.parse(File.read(bms2), headers: true)
sim_ms2_ttr = ms2_log.by_col[1].map(&:to_f)

unless sim_ttr.length < (k8s_ttr.length / 2) ||  sim_ttr.length > (k8s_ttr.length * 3 / 2.to_f)

  puts 'Simulated model'
  puts "MS1 - mean:#{sim_ms1_ttr.sum / sim_ms1_ttr.length} min: #{sim_ms1_ttr.min} max: #{sim_ms1_ttr.max}"
  puts "MS2 - mean:#{sim_ms2_ttr.sum / sim_ms2_ttr.length} min: #{sim_ms2_ttr.min} max: #{sim_ms2_ttr.max}"

  ks_e2e = stats.kstest(sim_ttr, k8s_ttr)
  ks_ms1 = stats.kstest(sim_ms1_ttr, ms1_ttr)
  ks_ms2 = stats.kstest(sim_ms2_ttr, ms2_ttr)
  #tt_ms1 = stats.ttest_ind(sim_ms1_ttr, ms1_ttr)
  #tt_ms2 = stats.ttest_ind(sim_ms2_ttr, ms2_ttr)

  # add a penalty if ms1 and ms2 do not pass the validation test

  res = ks_e2e.statistic.to_f
  puts "sim: #{ks_e2e}, ms1: #{ks_ms1}, ms2: #{ks_ms2}, reqs: #{sim_ttr.length}, res: #{res}"
end

puts "exiting"
exit 0